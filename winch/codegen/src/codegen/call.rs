use super::CodeGenContext;
use crate::{
    abi::{align_to, ABIArg, ABIResult, ABISig, ABI},
    masm::{MacroAssembler, OperandSize},
    reg::Reg,
    stack::Val,
};

/// All the information needed to emit a function call.
pub(crate) struct FnCall<'a> {
    /// The total stack space needed for the callee arguments on the
    /// stack, including any adjustments to the function's frame, for
    /// the alignment required by the ABI.
    pub total_arg_stack_space: u32,
    /// The stack space consumed by spilling registers placed as
    /// function arguments in the value stack.  This gets implicitly
    /// allocated by saving any live registers in the value stack, but
    /// we track it to make sure to reclaim that space once the
    /// function call ends.
    pub spill_stack_space: u32,
    /// The ABI-specific signature of the callee.
    pub abi_sig: &'a ABISig,
}

impl<'a> FnCall<'a> {
    /// Allocate a new function call.
    pub fn new<A: ABI, M: MacroAssembler>(
        abi: &A,
        callee_sig: &'a ABISig,
        context: &mut CodeGenContext,
        masm: &mut M,
    ) -> Self {
        let stack = &context.stack;
        let arg_stack_space = callee_sig.stack_bytes;
        let callee_params = &callee_sig.params;
        // Setup the function call.
        //
        // First, save all live registers in the value stack; tracking
        // down those spilled for the function arguments.
        //
        // Then calculate any adjustments needed to ensure the
        // alignment of the frame. It's important to note that then
        // order here matters, we want to calculate any adjustments to
        // the function's frame, *after* having saved any live
        // registers to account for any pushes generated by register
        // spilling.
        let spilled_regs = match callee_params.len() {
            0 => {
                let _ = context.spill_regs_in(masm, ..);
                0
            }
            _ => {
                assert!(stack.len() >= callee_params.len());
                let partition = stack.len() - callee_params.len();
                let _ = context.spill_regs_in(masm, 0..partition);
                context.spill_regs_in(masm, partition..)
            }
        };

        let delta = calculate_frame_adjustment(
            masm.sp_offset(),
            abi.arg_base_offset() as u32,
            abi.call_stack_align() as u32,
        );

        let total_arg_stack_space =
            align_to(arg_stack_space + delta, abi.call_stack_align() as u32);
        Self {
            abi_sig: &callee_sig,
            total_arg_stack_space,
            spill_stack_space: spilled_regs * <A as ABI>::word_bytes(),
        }
    }

    /// Emit the function call.
    pub fn emit<M: MacroAssembler, A: ABI>(
        &self,
        masm: &mut M,
        context: &mut CodeGenContext,
        callee: u32,
    ) {
        masm.reserve_stack(self.total_arg_stack_space);
        self.assign_args(context, masm, <A as ABI>::scratch_reg());
        masm.call(callee);
        masm.free_stack(self.spill_stack_space + self.total_arg_stack_space);
        context.drop_last(self.abi_sig.params.len());
        self.handle_result(context, masm);
    }

    fn assign_args<M: MacroAssembler>(
        &self,
        context: &mut CodeGenContext,
        masm: &mut M,
        scratch: Reg,
    ) {
        let arg_count = self.abi_sig.params.len();
        let mut stack_values = context.stack.peekn(arg_count);
        self.abi_sig.params.iter().for_each(|arg| {
            let val = stack_values.next().unwrap();
            match &arg {
                &ABIArg::Reg { ty, reg } => {
                    context.move_val_to_reg(*val, *reg, masm, (*ty).into());
                }
                &ABIArg::Stack { ty, offset } => {
                    let addr = masm.address_from_sp(*offset);
                    let size: OperandSize = (*ty).into();
                    context.move_val_to_reg(*val, scratch, masm, size);
                    masm.store(scratch.into(), addr, size);
                }
            }
        });
    }

    fn handle_result<M: MacroAssembler>(&self, context: &mut CodeGenContext, masm: &mut M) {
        let result = &self.abi_sig.result;
        if result.is_void() {
            return;
        }

        match result {
            &ABIResult::Reg { ty: _, reg } => {
                assert!(context.regalloc.gpr_available(reg));
                let result_reg = Val::reg(context.gpr(reg, masm));
                context.stack.push(result_reg);
            }
        }
    }
}

/// Calculates the delta needed to adjust a function's frame plus some
/// addend to a given alignment.
fn calculate_frame_adjustment(frame_size: u32, addend: u32, alignment: u32) -> u32 {
    let total = frame_size + addend;
    (alignment - (total % alignment)) % alignment
}
